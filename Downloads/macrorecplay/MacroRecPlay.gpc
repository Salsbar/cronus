#pragma METAINFO("MacroRecPlay", 1, 07, "Scachi")
#include <display.gph>
#include "MacroRecPlay_ic.gph"
#include "MacroRecPlay_or.gph"
#include "ICPM_Update.gph" // limit speed of writing to pmem and refresh of Interactive Configuration

/***   ToDo:
              nothing atm
      Latest change: v1.06 : Added option to add a pause in minutes between each macro loop run
***/

bool CFGERROR     = FALSE;

// state helper
bool bRecording   = FALSE;
bool bRecordStart = FALSE;
bool bRecordStop  = FALSE;
bool bRecordPrep  = FALSE;

bool bPlay        = FALSE;
bool bPlayStart   = FALSE;
bool bPlayStop    = FALSE;

// recording time tracking
//int32 RecTime = 0;

// tracking press of buttons, block next processing until the buttons are released
bool StartBtnA_Released = TRUE;
bool StartBtnB_Released = TRUE;
bool PlayBtnA_Released  = TRUE;
bool PlayBtnB_Released  = TRUE;
bool PlayStopBtnA_Released  = TRUE;
bool PlayStopBtnB_Released  = TRUE;

uint8 MacrofileDefault  = 0; // default macrofile combobox id on start of script
uint8 MacroFileActive   = 0;   // currently active macro file
uint8 MacroFileLetters[]= {_a_,_b_,_c_,_d_,_e_,_f_,_g_,_h_,_i_};

bool  MacroFileUseDef[] = {0,0,0,0,0,0,0,0,0}; // use default settings flag
uint16 MacroFileLoop[]   = {0,0,0,0,0,0,0,0,0}; // macrofile specific looping
uint8 MacroFileLoopPause[]   = {0,0,0,0,0,0,0,0,0}; // macrofile specific pause time (minutes) after each loop
int32 MacroFileSkip[]   = {0,0,0,0,0,0,0,0,0}; // macrofile specific skip time
int32 MacroFileTime[]   = {0,0,0,0,0,0,0,0,0}; // macrofile specific recording time

/*** comboboxindex for  Macro file selection cycle buttons  ***/
//#define MSel_None0      0   //item        = - NONE -
//#define MSel_PS         1   //item        = ::::::::::::: Playstation ::::::::::::::::::
#define MSel_L3L1_L3R1  2   //item        = L3+L1                //  L3+R1
#define MSel_R3L1_R3R1  3   //item        = R3+L1               //  R3+R1
#define MSel_L3PS_R3PS  4   //item        = L3+PS               //  R3+PS
#define MSel_R3DL_R3DR  5   //item        = R3+Dpad_Left  //  R3+Dpad_Right
#define MSel_R3DU_R3DD  6   //item        = R3+Dpad_Up    //  R3+Dpad_Down
//#define MSel_XB         7   //item        = :::::::::::::::: XBox ::::::::::::::::::::::
#define MSel_LSLB_LSRB  8   //item        = LS+LB                //  LS+RB
#define MSel_RSLB_RSRB  9   //item        = RS+LB               //  RS+RB
#define MSel_LSXB_RSXB  10  //item        = LS+Xbox           //  RS+Xbox
#define MSel_RSDL_RSDR  11  //item        = RS+Dpad_Left  //  RS+Dpad_Right
#define MSel_RSDU_RSDD  12  //item        = RS+Dpad_Up    //  RS+Dpad_Down

uint8 MacroSelectMode = 0; // for cycling through the macro files
bool  MacroRecallLast = 1; // save last used macrofile_combobox id ?
bool  MacroPlayOnLoad = 0; // to start playback of the last used macro on script load
uint8 MC_Hold1=0, MC_Tap1=0, MC_Hold2=0, MC_Tap2=0;

/***    START RECORD    ***/
// combobox index for start action
#define Start_Tap       0 // on press / event_active
#define Start_Hold      1 // hold down button >= holdtime
#define Start_DblTap    2 // double tap button
#define Start_HoldTap   3 // hold A and tap B

// checkbox for start recording on next input after enabling recording
bool    Start_NextAct   = FALSE; // on next action/input after start action

// start stuff
uint8 StartMode       = 3; // start on next input after hold-time of L3 >= 2 secs
uint8 StartBtnA       = 9; // L3
uint8 StartBtnB       = 0; // None
uint8 StartHoldTime   = 2;


/***    STOP RECORD    ***/
// combobox index for stop action
#define Stop_Tap        0 // hold down button >= holdtime
#define Stop_Hold       1 // hold down button >= holdtime
#define Stop_DblTap     2 // double tap button
#define Stop_HoldTap    3 // hold A and tap B
#define Stop_Tap_B      4 // tap B
#define Stop_Hold_B     5 // hold down button Beta >= holdtime
#define Stop_DblTap_B   6 // double tap button Beta
#define Stop_HoldTap_B  7 // hold B and tap A
#define Stop_Idle       8 // inactivity

// stop stuff
uint8 StopMode        = 8; // stop on inactivity
uint8 StopHoldTime    = 2;
uint8 StopIdleTime    = 5; // inactivity/idle stop time seconds


/***    PLAYBACK      ***/
// combobox index for play action
#define Play_Tap        0 // tap button
#define Play_Hold       1 // hold down button >= holdtime
#define Play_DblTap     2 // double tap button
#define Play_HoldTap    3 // hold A and tap B

// play stuff (start/toggle)
uint8 PlayMode        = 1; // holding down PlayBtnA
uint8 PlayBtnA        = 8; // R3
uint8 PlayBtnB        = 0; // None
uint8 PlayHoldTime    = 2;


// combobox index for play stop action
#define PlayStop_Tap        0 // tap button
#define PlayStop_Hold       1 // hold down button >= holdtime
#define PlayStop_DblTap     2 // double tap button
#define PlayStop_HoldTap    3 // hold A and tap B
#define PlayStop_Toggle     4 // use the same buttons for start and stop of playback (default)

// play stop stuff
bool  PlayStopModeToggle  = FALSE;
uint8 PlayStopMode        = 1; // holding down PlayStopBtnA
uint8 PlayStopBtnA        = 8; // R3
uint8 PlayStopBtnB        = 0; // None
uint8 PlayStopHoldTime    = 2;

// play stuff default macro settings
uint16 PlayLoopsDef   = 0; // play back that many time 0 = endless , default value
uint8  PlayPauseLoopDef = 0; // minutes to pause between each playback
uint32 PlayPauseTracker = 0;
int32 PlaySkipEndDef  = 0; // to skip playback of some ms at the end of recording , default value


uint32 LoopCount      = 0; // keep track of the times the macro has run & restarted

uint8 SlotActive      = 0; // for using the correct file names

// 9 macros / filenames per slot
char *files[]          = {
  "macrp1A.gmk","macrp1B.gmk","macrp1C.gmk","macrp1D.gmk","macrp1E.gmk","macrp1F.gmk","macrp1G.gmk","macrp1H.gmk","macrp1I.gmk",
  "macrp2A.gmk","macrp2B.gmk","macrp2C.gmk","macrp2D.gmk","macrp2E.gmk","macrp2F.gmk","macrp2G.gmk","macrp2H.gmk","macrp2I.gmk",
  "macrp3A.gmk","macrp3B.gmk","macrp3C.gmk","macrp3D.gmk","macrp3E.gmk","macrp3F.gmk","macrp3G.gmk","macrp3H.gmk","macrp3I.gmk",
  "macrp4A.gmk","macrp4B.gmk","macrp4C.gmk","macrp4D.gmk","macrp4E.gmk","macrp4F.gmk","macrp4G.gmk","macrp4H.gmk","macrp4I.gmk",
  "macrp5A.gmk","macrp5B.gmk","macrp5C.gmk","macrp5D.gmk","macrp5E.gmk","macrp5F.gmk","macrp5G.gmk","macrp5H.gmk","macrp5I.gmk",
  "macrp6A.gmk","macrp6B.gmk","macrp6C.gmk","macrp6D.gmk","macrp6E.gmk","macrp6F.gmk","macrp6G.gmk","macrp6H.gmk","macrp6I.gmk",
  "macrp7A.gmk","macrp7B.gmk","macrp7C.gmk","macrp7D.gmk","macrp7E.gmk","macrp7F.gmk","macrp7G.gmk","macrp7H.gmk","macrp7I.gmk",
  "macrp8A.gmk","macrp8B.gmk","macrp8C.gmk","macrp8D.gmk","macrp8E.gmk","macrp8F.gmk","macrp8G.gmk","macrp8H.gmk","macrp8I.gmk",
  "macrp9A.gmk","macrp9B.gmk","macrp9C.gmk","macrp9D.gmk","macrp9E.gmk","macrp9F.gmk","macrp9G.gmk","macrp9H.gmk","macrp9I.gmk",
  // 0 for debug slot
  "macrp0A.gmk","macrp0B.gmk","macrp0C.gmk","macrp0D.gmk","macrp0E.gmk","macrp0F.gmk","macrp0G.gmk","macrp0H.gmk","macrp0I.gmk",
}; // 0,9,18,27,36,45,54,63,72,81

#define MacroFilesIdx (SlotActive*9+MacroFileActive)// return the index for filename
#define printfMacroFile printf(files[MacroFilesIdx]) // printf the filename

init {
  pmem_load();
  
  pmem_read(0,&MacrofileDefault); // macro file combobox id active on default
  pmem_read(1,&MacroSelectMode);  // for cycling through the macro files
  MacroRecallLast = (pmem_read(2) >> 0) & 0b1; // save last used macrofile_combobox id
  MacroPlayOnLoad = (pmem_read(2) >> 2) & 0b1; // start playback on script load
  
  // assign macro cycle/selection keys according to selection
  switch(MacroSelectMode) {
        // L3/LS R3/RS
        case MSel_L3L1_L3R1: 
        case MSel_LSLB_LSRB: MC_Hold1=BUTTON_9; MC_Tap1=BUTTON_7; MC_Hold2=BUTTON_9; MC_Tap2=BUTTON_4;
        break;
        case MSel_R3L1_R3R1: 
        case MSel_RSLB_RSRB: MC_Hold1=BUTTON_6; MC_Tap1=BUTTON_7; MC_Hold2=BUTTON_6; MC_Tap2=BUTTON_4;
        break;
        // ps/xb
        case MSel_L3PS_R3PS:
        case MSel_LSXB_RSXB: MC_Hold1=BUTTON_9; MC_Tap1=BUTTON_1; MC_Hold2=BUTTON_6; MC_Tap2=BUTTON_1;
        break;
        // dpad
        case MSel_R3DL_R3DR: 
        case MSel_RSDL_RSDR: MC_Hold1=BUTTON_6; MC_Tap1=BUTTON_12; MC_Hold2=BUTTON_6; MC_Tap2=BUTTON_13;
        break;
        case MSel_R3DU_R3DD: 
        case MSel_RSDU_RSDD: MC_Hold1=BUTTON_6; MC_Tap1=BUTTON_10; MC_Hold2=BUTTON_6; MC_Tap2=BUTTON_11;
        break;
        // skip -NONE- and "headline" values
        default:// printf("switch default: break");
        break;
  }
  
  pmem_read(3,&StartMode);        // start init mode
  Start_NextAct = (pmem_read(2) >> 1) & 0b1; // start recording after next activity
  pmem_read(4,&PlayPauseLoopDef); // minutes to pause between each playback
  pmem_read(5,&StartHoldTime);    // start hold time
  pmem_read(6,&StartBtnA);        // button a to press for start
  if ( StartBtnA == 0 ) StartBtnA=41;
  else StartBtnA=StartBtnA-1;
  
  pmem_read(7,&StartBtnB);        // button b to press for start
  if ( StartBtnB == 0 ) StartBtnB=41;
  else StartBtnB=StartBtnB-1;
  
  pmem_read(10,&StopMode);        // stop init mode
  pmem_read(11,&StopHoldTime);    // stop hold time
  pmem_read(12,&StopIdleTime);    // idle time required before stop recording
  
  // play start
  pmem_read(20,&PlayMode);        // play init mode
  pmem_read(21,&PlayHoldTime);    // play hold time
  pmem_read(22,&PlayBtnA);        // the button a to press for playback
  if ( PlayBtnA == 0 ) PlayBtnA=41;
  else PlayBtnA=PlayBtnA-1;
  
  pmem_read(23,&PlayBtnB);        // the button b to press for playback
  if ( PlayBtnB == 0 ) PlayBtnB=41;
  else PlayBtnB=PlayBtnB-1;
  
  // play stop settings
  pmem_read(16,&PlayStopMode);        // play init mode
  pmem_read(17,&PlayStopHoldTime);    // play hold time
  pmem_read(18,&PlayStopBtnA);        // the button a to press for playback
  if ( PlayStopBtnA == 0 ) PlayStopBtnA=41;
  else PlayStopBtnA=PlayStopBtnA-1;
  
  pmem_read(19,&PlayStopBtnB);        // the button b to press for playback
  if ( PlayStopBtnB == 0 ) PlayStopBtnB=41;
  else PlayStopBtnB=PlayStopBtnB-1;
  
  // playback TOGGLE
  // use the playback start setting to stop / toggle state
  if (PlayStopMode == PlayStop_Toggle) {
    PlayStopModeToggle = TRUE;
    PlayStopMode = PlayMode;
    PlayStopHoldTime= PlayHoldTime;
    PlayStopBtnA = PlayBtnA;
    PlayStopBtnB = PlayBtnB;
  }
  //printf(" %d %d %d %d ",PlayMode, PlayHoldTime, PlayBtnA, PlayBtnB);
  //printf(" %d %d %d %d ",PlayStopMode, PlayStopHoldTime, PlayStopBtnA, PlayStopBtnB);
  
  CFGERROR=CfgErrorCheck();       // configuration error checking, blink red fast if problems are found
  
  // for each macro file:
  pmem_read(24,&PlayLoopsDef);    // play back that many times
  pmem_read(26,&PlaySkipEndDef);  // skip playback time at the end of the recording
  //printf("time to skip at the end: %ld",PlaySkipEnd); // 4debug
  
  SlotActive=mslot_get() -1;
  SlotActive=clamp(SlotActive,0,9);      // point to the filenames to use by the active T2 slot
      
  MacroFileActive = MacrofileDefault;     // the currently selected macrofile
  //printf("macrofileactive: %d, slotactive: %d",MacroFileActive,SlotActive);
  display_overlay(MacroFileLetters[MacroFileActive],3000);
  
  //printf(files[SlotActive*9+MacroFileActive]);
  //printf(files[MacroFilesIdx]);
  //printfMacroFile;
  
  // macrofile specific settings
  uint8 ri;
  uint8 LoopBitoffset;
  uint8 LoopDummy;
  for (ri=0;ri<9;ri++) {
    if (ri < 8 ) {
      pmem_read(120,&LoopDummy);
    } else {
      pmem_read(121,&LoopDummy);
    }
    LoopBitoffset= ri%8;
    MacroFileUseDef[ri] =(LoopDummy >> LoopBitoffset) & 0b1;    // default loopcount usage flag
    //printf("bitoffset: %d , flag: %d",LoopBitoffset, MacroFileUseDef[ri]);
    pmem_read(30+ri*10,&MacroFileLoop[ri]   ); // loop count
    pmem_read(32+ri*10,&MacroFileSkip[ri]   ); // skip time of the recording at the end
    pmem_read(36+ri*10,&MacroFileTime[ri]   ); // recording time
	if (ri < 6) pmem_read(122+ri,&MacroFileLoopPause[ri]   ); // minutes to pause between each playback, offset 122..127 (a..f)
	else pmem_read(7+ri,&MacroFileLoopPause[ri]   ); // minutes to pause between each playback, offset 13..15 (g..i)

    //printf("usedef: %d, loop: %d, skip: %d, time: %d",MacroFileUseDef[ri],MacroFileLoop[ri],MacroFileSkip[ri],MacroFileTime[ri]);
  }
  
  ICPM_Update(5000); // set pmem write interval for changes
/*  
  printf("Macrofile time : %d ",MacroFileTime[MacroFileActive]);
  printf("defskiptime: %d", PlaySkipEndDef);
  printf("time to play: %d",MacroFileTime[MacroFileActive]-PlaySkipEndDef);
*/
  if (MacroPlayOnLoad) bPlayStart = TRUE;
}

main {
  // only use the MacroControl when no configuration error was found
  if ( !CFGERROR ) MacroControl();
}


void MacroControl() {
    
  BtnsReleaseUpdate();
    
  /*** --- macrofilename cycle --- / --- start recording --- ***/
  // check for trigger start macro recording if no recording or playing is active
  if (!bRecording && !bRecordStart && !bRecordStop && !bPlay && !bPlayStart && !bPlayStop && !bRecordPrep
        && BtnsReleased() )
  { 
      /***  start recording ***/
      switch(StartMode) {
        case Start_Tap    : if (event_active(StartBtnA)) RecordStartOrPrep_Flag();
        break;
        case Start_Hold   : if (check_active(StartBtnA,StartHoldTime*1000) && getLastButtonActive() == StartBtnA) RecordStartOrPrep_Flag();
        break;
        case Start_DblTap : if (event_active(StartBtnA) && time_release(StartBtnA) < 200) RecordStartOrPrep_Flag();
        break;
        case Start_HoldTap: if (get_val(StartBtnA) && event_active(StartBtnB)) RecordStartOrPrep_Flag();
        break;
        
      }
      
      /***  cycle through macronames ***/
      if (!bRecording && !bRecordPrep && MacroSelectMode) MacroFileCycle(MC_Hold1,MC_Tap1,MC_Hold2,MC_Tap2);
  }

  // start recording check
  if (!bRecording && !bRecordStop && !bPlay && !bPlayStart && !bPlayStop
        && BtnsReleased() ) 
  {
    if (!bRecordStart && bRecordPrep) bRecordStart=AnyActivity(); // check for any event_active
    if (bRecordStart) {
        bRecording=TRUE;
        bRecordPrep=FALSE;bRecordStart=FALSE; bRecordStop=FALSE; bPlay=FALSE; bPlayStart=FALSE; bPlayStop=FALSE;
        BtnsSetPressed();
        printf("started recording of:");
        printfMacroFile;
        ColorLEDVM('P',0,0,-1);
        macro_rec(files[MacroFilesIdx]);
        combo_run(RecordCheck); // test in 300ms if the recording works
    }
  } // eo: start recording
  //
  
  /*** --- stop recording --- ***/
  if (bRecording && BtnsReleased()) {
      if (!bRecordStop) {
        switch(StopMode) {
          case Stop_Tap     : if (event_active(StartBtnA)) RecordStop_Flag();
          break;
          case Stop_Hold    : if (check_active(StartBtnA,StopHoldTime*1000) && getLastButtonActive()==StartBtnA) RecordStop_Flag();
          break;
          case Stop_DblTap  : if (event_active(StartBtnA) && time_release(StartBtnA) < 200) RecordStop_Flag();
          break;
          case Stop_HoldTap : if (get_val(StartBtnA) && event_active(StartBtnB)) RecordStop_Flag();
          break;          
          case Stop_Tap_B   :  if (event_active(StartBtnB)) RecordStop_Flag();
          break;
          case Stop_Hold_B  : if (check_active(StartBtnB,StopHoldTime*1000) && getLastButtonActive()==StartBtnB) RecordStop_Flag();
          break;
          case Stop_DblTap_B: if (event_active(StartBtnB) && time_release(StartBtnB) < 200) RecordStop_Flag();
          break;
          case Stop_HoldTap_B: if (get_val(StartBtnB) && event_active(StartBtnA)) RecordStop_Flag();
          break;
          case Stop_Idle    : bRecordStop=NoActivity(StopIdleTime*1000); break;

        }
      }
  }
  
  if (bRecording && bRecordStop) {
    bRecording=FALSE; bRecordStop=FALSE;    
    BtnsSetPressed();
    MacroFileTime[MacroFileActive]=macro_time();
    macro_stop();
    pmem_write(36+10*MacroFileActive,MacroFileTime[MacroFileActive]);
    ICPM_Update(TRUE);
    printf("stopped recording after %ldms of file:",MacroFileTime[MacroFileActive]);
    printfMacroFile;
    ColorLEDVM('B',0,0,-1);
  }
  
  
  /*** --- play back start --- ***/
  if (!bRecording && !bPlayStart && !bPlayStop && BtnsReleased() && !bPlay) {
      switch(PlayMode) {
          case Play_Tap     : if (event_active(PlayBtnA)) PlayStart_Flag();
          break;
          case Play_Hold    : if (check_active(PlayBtnA,PlayHoldTime*1000) && getLastButtonActive()==PlayBtnA) PlayStart_Flag();
          break;
          case Play_DblTap  : if (event_active(PlayBtnA) && time_release(PlayBtnA) < 200) PlayStart_Flag();
          break;
          case Play_HoldTap : if (get_val(PlayBtnA) && event_active(PlayBtnB)) PlayStart_Flag();
          break;
      }
  }
  
  /*** --- play back stop --- ***/
  if (!bRecording && !bPlayStart && !bPlayStop && BtnsReleased() && bPlay) {
      switch(PlayStopMode) {
          case Play_Tap     : if ( event_active(PlayStopBtnA)) PlayStop_Flag();
          break;
          case Play_Hold    : if ( check_active(PlayStopBtnA,PlayStopHoldTime*1000) && getLastButtonActive()==PlayStopBtnA) PlayStop_Flag();
          break;
          case Play_DblTap  : if ( event_active(PlayStopBtnA) && time_release(PlayStopBtnA) < 200) PlayStop_Flag();
          break;
          case Play_HoldTap : if ( get_val(PlayStopBtnA) && event_active(PlayStopBtnB)) PlayStop_Flag();
          break;
      }
  }
  
    // start
    if (!bPlay && bPlayStart) {
      LoopCount=0;
      BtnsSetPressed(); 
      bPlay = TRUE;
      bPlayStart = FALSE;
      ColorLEDVM('G',0,0,-1);
      printf("Start macro run: %d of file:",LoopCount+1);
      printfMacroFile;
      macro_run(files[MacroFilesIdx]);
	  if (MacroFileUseDef[MacroFileActive]) PlayPauseTracker = PlayPauseLoopDef*60000;
	  else PlayPauseTracker=MacroFileLoopPause[MacroFileActive]*60000; // reset pause time between loops
    }
    
    // stop
    else if (bPlay && bPlayStop) {
      BtnsSetPressed(); 
      bPlay = FALSE;
      bPlayStop = FALSE;
      ColorLEDVM('B',0,0,-1);
      printf("Stopped playback run: %d of file:",LoopCount+1);
      printfMacroFile;
      macro_stop();
    }
    
    
  
  /*** --- do Playback --- ***/
  if (bPlay && !bPlayStop) {
      // use default loop and skip ?
      if (MacroFileUseDef[MacroFileActive]) {
        // check if to skip the rest of the playback now, example: 60sec    - 4sec  >  50sec
        //if (mod((fix32)macro_time(),100f) == 0.0) printf("%d",macro_time());        
        if (PlaySkipEndDef > 0 && MacroFileTime[MacroFileActive] - PlaySkipEndDef <= macro_time()) {
          printf("play back was active for %ldms - skipping at the end %ldms", macro_time(), PlaySkipEndDef);
          macro_stop();
        }
        
      } else { // macrofile specific settings
        if (MacroFileSkip[MacroFileActive] > 0 && MacroFileTime[MacroFileActive] - MacroFileSkip[MacroFileActive] <= macro_time()) {
          printf("play back was active for %ldms - skipping at the end %ldms", macro_time(), MacroFileSkip[MacroFileActive]);
          macro_stop();
        }
      }
      if ( macro_time() == -1 ) { // -1 == no macro operation active, playback done
	  if (PlayPauseTracker) { // pause time between loops
			  if (elapsed_time()) PlayPauseTracker--;
	  } else {
		LoopCount++;
		// default settings
		if (MacroFileUseDef[MacroFileActive]) {
			if ( LoopCount >= PlayLoopsDef && PlayLoopsDef > 0) {
			bPlayStop=TRUE; // selected amount of loops played
			} else {
				printf("Start run: %d of file:",LoopCount+1);
				printfMacroFile;
				macro_run(files[MacroFilesIdx]); // play again
				PlayPauseTracker=PlayPauseLoopDef*60000; // reset pause time between loops
			}
		} else { // macrofile specific settings
			if ( LoopCount >= MacroFileLoop[MacroFileActive] && MacroFileLoop[MacroFileActive] > 0) {
			bPlayStop=TRUE; // selected amount of loops played
			} else {
				printf("Start run: %d of file:",LoopCount+1);
				printfMacroFile;
				macro_run(files[MacroFilesIdx]); // play again
				PlayPauseTracker=MacroFileLoopPause[MacroFileActive]*60000; // reset pause time between loops
			}
		}
	  }
    }
  }

}

// some configuration error checking
bool CfgErrorCheck() {
  bool err=FALSE;
  
  /*** record configuration check ***/
  if ( StartBtnA == PlayBtnA && StartBtnB == PlayBtnB ) 
    { err=TRUE; printf("Can't use the same buttons for recording and playback!"); }
    
  if ( StartBtnA == 41) // 41 == nothing selected
    { err=TRUE; printf("Button 'Alpha' has to be selected"); }
    
  if ( (StartMode == Start_HoldTap || StopMode == Stop_HoldTap || StopMode == Stop_HoldTap_B) 
          && (StartBtnA == 41 || StartBtnB == 41))
    { err=TRUE; printf("Button 'Alpha' + 'Beta' has to be selected"); }
    
  
  if ( (StartMode == Start_Tap || StopMode == Stop_Tap) && StartBtnA == 41)
    { err=TRUE; printf("Button 'Alpha' has to be selected"); }
    
  if ( StopMode == Stop_HoldTap && (StartBtnA == 41 || StartBtnB == 41))
    { err=TRUE; printf("Button 'Alpha' + 'Beta' has to be selected"); }
    
  if ( (StopMode == Stop_Hold_B || StopMode == Stop_DblTap_B || StopMode == Stop_Tap_B) && StartBtnB == 41)
    { err=TRUE; printf("Button 'Beta' has to be selected"); }
    
    
  /*** play start configuration check ***/
  if ( PlayBtnA == 41) 
    { err=TRUE; printf("Button 'Gamma' has to be selected"); }

  if ( PlayMode == Play_HoldTap && (PlayBtnA == 41 || PlayBtnB == 41))
    { err=TRUE; printf("Button 'Gamma' + 'Delta' has to be selected"); }
    
  /*** play stop configuration check ***/
  //      only check when not using the same as playback start 
  if (!PlayStopModeToggle) {
    if ( PlayStopBtnA == 41) 
      { err=TRUE; printf("Button 'Epsilon' has to be selected"); }
  
    if ( PlayStopMode == PlayStop_HoldTap && (PlayStopBtnA == 41 || PlayStopBtnB == 41))
      { err=TRUE; printf("Button 'Epsilon' + 'Zeta' has to be selected"); }      
  }

    
  /*** macrofile change check ***/
  if ( StartBtnA == MC_Hold1 && StartBtnB == MC_Tap1 ) 
    { err=TRUE; printf("Can't use the same buttons for recording and macro file selection!"); }

  if ( StartBtnA == MC_Hold2 && StartBtnB == MC_Tap2 ) 
    { err=TRUE; printf("Can't use the same buttons for recording and macro file selection!"); }

  if ( PlayBtnA == MC_Hold1 && PlayBtnB == MC_Tap1 ) 
    { err=TRUE; printf("Can't use the same buttons for playback and macro file selection!"); }

  if ( PlayBtnA == MC_Hold2 && PlayBtnB == MC_Tap2 ) 
    { err=TRUE; printf("Can't use the same buttons for playback and macro file selection!"); }

  if (  (StartMode == Start_Tap && StartBtnA == MC_Tap1)
      ||(StopMode  == Stop_Tap  && PlayBtnA  == MC_Tap2)
     )
    { err=TRUE; printf("Start or Stop Tap button collides with macro file selection buttons"); }

    
  if (err) ColorLEDVM('R',100,100,-1);
  else ColorLEDVM('B',0,0,-1);
  return err;
}

// cycle 
bool MacroFileCycle(uint8 btnHoldDn, uint8 btnTapDn, uint8 btnHoldUp, uint8 btnTapUp) {
  bool changed = FALSE, event = FALSE;
  
  if (is_active(btnHoldDn) && event_active(btnTapDn)) {
    event=TRUE;
    if (MacroFileActive > 0) { MacroFileActive--; changed=TRUE; }
  }
  
  if (is_active(btnHoldUp) && event_active(btnTapUp)) {
    event=TRUE;
    if (MacroFileActive < 9) { MacroFileActive++; changed=TRUE; }
  }
  
  if (event) {
    display_overlay(MacroFileLetters[MacroFileActive],3000);
    if (changed && MacroRecallLast) {
      pmem_write(2,MacroRecallLast);       // save last used macrofile_combobox id
      ICPM_Update(TRUE);
    }
  }  
  return changed;
}

// check if the buttons are inactivity and set the release flag
void BtnsReleaseUpdate() {
  if (StartBtnA < 41 && !is_active(StartBtnA)) StartBtnA_Released=TRUE;
  if (StartBtnB < 41 && !is_active(StartBtnB)) StartBtnB_Released=TRUE;
  if (PlayBtnA < 41 && !is_active(PlayBtnA)) PlayBtnA_Released=TRUE;
  if (PlayBtnB < 41 && !is_active(PlayBtnB)) PlayBtnB_Released=TRUE;
  if (PlayStopBtnA < 41 && !is_active(PlayStopBtnA)) PlayStopBtnA_Released=TRUE;
  if (PlayStopBtnB < 41 && !is_active(PlayStopBtnB)) PlayStopBtnB_Released=TRUE;
}

// set all configured buttons to pressed to block next processing until they got released
void BtnsSetPressed() {
  if (StartBtnA < 41) StartBtnA_Released=FALSE;
  if (StartBtnB < 41) StartBtnB_Released=FALSE;
  if (PlayBtnA < 41)  PlayBtnA_Released=FALSE;
  if (PlayBtnB < 41)  PlayBtnB_Released=FALSE;
  if (PlayStopBtnA < 41)  PlayStopBtnA_Released=FALSE;
  if (PlayStopBtnB < 41)  PlayStopBtnB_Released=FALSE;
}

// check if all configured buttons are currently in release state
bool BtnsReleased() {
  if (StartBtnA < 41 && !StartBtnA_Released)  return FALSE;
  if (StartBtnB < 41 && !StartBtnB_Released)  return FALSE;
  if (PlayBtnA <  41 && !PlayBtnA_Released)   return FALSE;
  if (PlayBtnB <  41 && !PlayBtnB_Released)   return FALSE;
  if (PlayStopBtnA <  41 && !PlayStopBtnA_Released)   return FALSE;
  if (PlayStopBtnB <  41 && !PlayStopBtnB_Released)   return FALSE;
  return TRUE;
}

// set flag to start recording directly or on next input, LED feedback
void RecordStartOrPrep_Flag() {
  if (!Start_NextAct) {
    bRecordStart = TRUE; 
  } else {
    bRecordPrep = TRUE; 
    ColorLEDVM('A',150,150,-1); 
  }
  BtnsSetPressed();
}

// set flag to stop recording
void RecordStop_Flag() {
  bRecordStop = TRUE; 
  BtnsSetPressed(); 
}

combo RecordCheck {
  wait(300);
  bool err=FALSE;
  if (macro_time() == -1) {
    err=TRUE;
    printf("Recording is not working ?!? , macro_time() returned -1");
    ColorLEDVM('R',100,100,10);
  }
  wait(0);
  wait(2200);
  if (err) RecordStop_Flag();
  wait(0);
  wait(100);
}

// set flag to start play back
void PlayStart_Flag() {
  bPlayStart = TRUE;
  BtnsSetPressed();
}

// set flag to stop play back
void PlayStop_Flag() {
  bPlayStop = TRUE; 
  BtnsSetPressed();
}


// check all buttons for event_active 
bool AnyActivity() {
  uint8 i;
  for (i=0;i<25;i++) {
    if (event_active(i)) {
      BtnsSetPressed();
      return TRUE;
    }
  }
  return FALSE;
}


// check if there was no input for a period of idletime
bool NoActivity(uint32 idletime) {
  uint8 i;
  for (i=0;i<25;i++) {
    if (is_active(i)) return FALSE;
    if (time_release(i) < idletime) return FALSE;
  }
  printf("No activity in the last %d ms",idletime);
  return TRUE;
}

// LED Color 'C'olor , blink duration on , blink duration off, blink count
void ColorLEDVM(char Color, uint16 DurOn, uint16 DurOff, int Count) {
  if ( DurOff == 0 ) DurOn = 100;
	int Color1, Color2, Color3, Color4;
   
	if(Color == 'B'){Color1 = 1; Color2 = 0; Color3 = 0; Color4 = 0;}
	if(Color == 'R'){Color1 = 0; Color2 = 1; Color3 = 0; Color4 = 0;}
	if(Color == 'G'){Color1 = 0; Color2 = 0; Color3 = 1; Color4 = 0;}
	if(Color == 'P'){Color1 = 0; Color2 = 0; Color3 = 0; Color4 = 1;}
	if(Color == 'C'){Color1 = 1; Color2 = 0; Color3 = 1; Color4 = 0;}
	if(Color == 'A'){Color1 = 0; Color2 = 1; Color3 = 1; Color4 = 0;}
	if(Color == 'W'){Color1 = 1; Color2 = 1; Color3 = 1; Color4 = 1;}
	led_reset();
  if (Color1) if (DurOff > 0) led_vmset(LED_1, DurOn, DurOff, Count); else led_set(LED_1,(fix32)DurOn,0);
	if (Color2) if (DurOff > 0) led_vmset(LED_2, DurOn, DurOff, Count); else led_set(LED_2,(fix32)DurOn,0);
	if (Color3) if (DurOff > 0) led_vmset(LED_3, DurOn, DurOff, Count); else led_set(LED_3,(fix32)DurOn,0);
	if (Color4) if (DurOff > 0) led_vmset(LED_4, DurOn, DurOff, Count); else led_set(LED_4,(fix32)DurOn,0);
}

// last button with event_active
uint8 getLastButtonActive() {
	uint8 i, last = BUTTON_1;
	
	for(i=BUTTON_2; i<=BUTTON_21; ++i) {
		if(time_active(i) < time_active(last)) {
			last = i;
		}
	}
	return(last);
}
